# 1. 浏览器的本地存储cookie了解多少？

cookie最开始设计出来其实并不是为了本地储存的，而是为了弥补http在状态管理上的不足

http是一个无状态的协议，客户端向服务器发起一个请求，服务器端进行响应，这次的事件就结束了，但是在下次发起请求的时候服务器端不知道是哪一个客户端来的，所以就产生了cookie的概念

cookie其实就是存储在浏览器端的一个小的文本文件，内部以键值对的方式进行存储，

# 2. 浏览器进程和线程

+ 进程是操作系统资源分配的基本单位，一个进程就是一个程序的运行实例，进程当中包括线程；启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放内存、运行的数据和一个执行任务的主线程，我们把这样的一个运行环境叫做**进程**，进程中使用多线程并行处理能提高运算效率
+ 线程是由进程来启动和管理的，线程是不允许单独存在的，为了提示浏览器的稳定性和安全性，浏览器采用了多进程模型

**进程和线程之间的关系具有如下几个特点：**

1. 进程中的任一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据，线程之间可以对进程的公共数据进行读写操作
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存；即使进程中任意线程因为操作不当导致内存泄漏，当进程退出是，这些内存也会被回收
4. 进程之间的内容是相互隔离的，由于这个特性，即使一个进程崩溃也不会影响其他进程，如果进程之间需要进行数据的通信，就需要使用进程间通信的**IPC**机制

# 3. 浏览器当中的5个进程

+ 渲染进程：每个显卡都有单独的渲染进程，核心用于渲染页面
+ 插件进程： chrome安装一些插件
+ 网络进程：主要处理网络资源加载(html,css,js)
+ 浏览器进程： 负责页面显示，用户交互，子进程管理，提供存储等等
+ GPU进程： 3d绘制,提高性能

# 4. 从输入URL到浏览器显示页面发生了什么?

首先确定的是用户输入的是关键字还是url

如果是关键字，会交给浏览器的默认搜索引擎生产URL

如果是url则是如下操作：

# 5. HTTP发展历程

+ HTTP/0.9 在传输过程中没有请求头和请求体，服务器响应没有返回头信息，内容采用ASCII字符流来进行传输 HTML

+ HTTP/1.0 增加了请求头和响应头，实现多类型数据传输

+ HTTP/1.1 默认开启持久链接，在一个TCP链接上可以传输多个HTTP请求 ， 采用管线化的方式（每个域名最多维护6个TCP持久链接）解决队头阻塞问题 （服务端需要按顺序依次处理请求）。完美支持数据分块传输（chunk transfer），并引入客户端cookie机制、安全机制等。

+ HTTP/2.0 解决网络带宽使用率低 （TCP慢启动，多个TCP竞争带宽，队头阻塞）采用多路复用机制（一个域名使用一个TCP长链接，通过二进制分帧层来实现）。头部压缩（HPACK）、及服务端推送

+ HTTP/3.0 解决TCP队头阻塞问题， 采用QUIC协议。QUIC协议是基于UDP的 （目前：支持和部署是最大的问题）

+ HTTP明文传输, 在传输过程中会经历路由器、运营商等环节，数据有可能被窃取或篡改 （安全问题）

# 6. 


